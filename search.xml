<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Hello World</title>
      <link href="/2020/09/06/%E5%85%B6%E4%BB%96/hello-world/"/>
      <url>/2020/09/06/%E5%85%B6%E4%BB%96/hello-world/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><a id="more"></a><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> TEST </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TEST </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>为什么要学习数据结构和算法？</title>
      <link href="/2020/07/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A6%82%E5%BF%B5/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%AD%A6%E4%B9%A0%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%EF%BC%9F/"/>
      <url>/2020/07/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A6%82%E5%BF%B5/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%AD%A6%E4%B9%A0%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>你是不是觉得数据结构和算法，跟操作系统、计算机网络一样，是脱离实际工作的知识？可能除了面试，这辈子也用不着？</p></blockquote><p>尽管计算机相关专业的同学在大学都学过这门课程，甚至很多培训机构也会培训这方面的知识，但是据我了解，很多程序员对数据结构和算法依旧一窍不通。还有一些人也只听说过数组、链表、快排这些最最基本的数据结构和算法，稍微复杂一点的就完全没概念。</p><p>当然，也有很多人说，自己实际工作中根本用不到数据结构和算法。所以，就算不懂这块知识，只要Java API、开发框架用得熟练，照样可以把代码写得“飞”起来。事实真的是这样吗?</p><p>今天我们就来详细聊一聊，为什么要学习数据结构和算法。<br><a id="more"></a></p><h3 id="⭐-想要通关大厂面试，千万别让数据结构和算法拖了后腿"><a href="#⭐-想要通关大厂面试，千万别让数据结构和算法拖了后腿" class="headerlink" title="⭐ 想要通关大厂面试，千万别让数据结构和算法拖了后腿"></a>⭐ 想要通关大厂面试，千万别让数据结构和算法拖了后腿</h3><p>很多大公司，比如<code>BAT</code>、<code>Google</code>、<code>Facebook</code>，面试的时候都喜欢考算法、让人现场写代码。有些人虽然技术不错，但每次去面试都会“跪”在算法上，很是可惜。那你有没有想过，为什么这些大公司都喜欢考算法呢？</p><p>校招的时候，参加面试的学生通常没有实际项目经验，公司只能考察他们的基础知识是否牢固。社招就更不用说了，越是厉害的公司，越是注重考察数据结构与算法这类基础知识。相比短期能力，他们更看中你的长期潜力。</p><p>你可能要说了，我不懂数据结构与算法，照样找到了好工作啊。那我是不是就不用学数据结构和算法呢？当然不是，你别忘了，我们学任何知识都是为了“用”的，是为了解决实际工作问题的，学习数据结构和算法自然也不例外。</p><h3 id="⭐-业务开发工程师，你真的愿意做一辈子CRUD-boy吗？"><a href="#⭐-业务开发工程师，你真的愿意做一辈子CRUD-boy吗？" class="headerlink" title="⭐ 业务开发工程师，你真的愿意做一辈子CRUD boy吗？"></a>⭐ 业务开发工程师，你真的愿意做一辈子CRUD boy吗？</h3><p>如果你是一名业务开发工程师，你可能要说，我整天就是做数据库CRUD（增删改查），哪里用得到数据结构和算法啊？<br>是的，对于大部分业务开发来说，我们平时可能更多的是利用已经封装好的现成的接口、类库来堆砌、翻译业务逻辑，很少需要自己实现数据结构和算法。但是，不需要自己实现，并不代表什么都不需要了解。</p><p>如果不知道这些类库背后的原理，不懂得时间、空间复杂度分析，你如何能用好、用对它们？存储某个业务数据的时候，你如何知道应该用ArrayList，还是LinkedList呢？调用了某个函数之后，你又该如何评估代码的性能和资源的消耗呢？</p><p>作为业务开发，我们会用到各种框架、中间件和底层系统，比如Spring、RPC框架、消息中间件、Redis等等。在这些基础框架中，一般都揉和了很多基础数据结构和算法的设计思想。<br>比如，我们常用的Key-Value数据库Redis中，里面的有序集合是用什么数据结构来实现的呢？为什么要用跳表来实现呢？为什么不用二叉树呢？</p><p>如果你能弄明白这些底层原理，你就能更好地使用它们。即便出现问题，也很容易就能定位。因此，掌握数据结构和算法，不管对于阅读框架源码，还是理解其背后的设计思想，都是非常有用的。</p><p>在平时的工作中，数据结构和算法的应用到处可见。我来举一个你非常熟悉的例子：如何实时地统计业务接口的响应时间？<br>你可能最先想到，每次查询时，从小到大排序所有的响应时间，如果总共有1200个数据，那第1188个数据就是99%的响应时间。很显然，每次用这个方法查询的话都要排序，效率是非常低的。但是，如果你知道“堆”这个数据结构，用两个堆可以非常高效地解决这个问题。</p><h3 id="⭐-基础架构研发工程师，写出达到开源水平的框架才是你的目标！"><a href="#⭐-基础架构研发工程师，写出达到开源水平的框架才是你的目标！" class="headerlink" title="⭐ 基础架构研发工程师，写出达到开源水平的框架才是你的目标！"></a>⭐ 基础架构研发工程师，写出达到开源水平的框架才是你的目标！</h3><p>现在互联网上的技术文章、架构分享、开源项目满天飞，照猫画虎做一套基础框架并不难。我就拿RPC框架举例。</p><p>不同的公司、不同的人做出的RPC框架，架构设计思路都差不多，最后实现的功能也都差不多。但是有的人做出来的框架，Bug很多、性能一般、扩展性也不好，只能在自己公司仅有的几个项目里面用一下。而有的人做的框架可以开源到GitHub上给很多人用，甚至被Apache收录。为什么会有这么大的差距呢？<br>我觉得，高手之间的竞争其实就在细节。这些细节包括：你用的算法是不是够优化，数据存取的效率是不是够高，内存是不是够节省等等。这些累积起来，决定了一个框架是不是优秀。所以，如果你还不懂数据结构和算法，没听说过大O复杂度分析，不知道怎么分析代码的时间复杂度和空间复杂度，那肯定说不过去了，赶紧来补一补吧！</p><h3 id="⭐-对编程还有追求？不想被行业淘汰？那就不要只会写凑合能用的代码！"><a href="#⭐-对编程还有追求？不想被行业淘汰？那就不要只会写凑合能用的代码！" class="headerlink" title="⭐ 对编程还有追求？不想被行业淘汰？那就不要只会写凑合能用的代码！"></a>⭐ 对编程还有追求？不想被行业淘汰？那就不要只会写凑合能用的代码！</h3><p>何为编程能力强？是代码的可读性好、健壮？还是扩展性好？我觉得没法列，也列不全。但是，在我看来，性能好坏起码是其中一个非常重要的评判标准。但是，如果你连代码的时间复杂度、空间复杂度都不知道怎么分析，怎么写出高性能的代码呢？</p><p>你可能会说，我在小公司工作，用户量很少，需要处理的数据量也很少，开发中不需要考虑那么多性能的问题，完成功能就可以，用什么数据结构和算法，差别根本不大。但是你真的想“十年如一日”地做一样的工作吗？经常有人说，程序员35岁之后很容易陷入瓶颈，被行业淘汰，我觉得原因其实就在此。有的人写代码的时候，从来都不考虑非功能性的需求，只是完成功能，凑合能用就好；做事情的时候，也从来没有长远规划，只把眼前事情做好就满足了。</p><p>有些人简历能写十几页，经历的项目有几十个，但是细看下来，每个项目都是重复地堆砌业务逻辑而已，完全没有难度递进，看不出有能力提升。久而久之，十年的积累可能跟一年的积累没有任何区别。这样的人，怎么不会被行业淘汰呢？<br>如果你在一家成熟的公司，或者BAT这样的大公司，面对的是千万级甚至亿级的用户，开发的是TB、PB级别数据的处理系统。性能几乎是开发过程中时刻都要考虑的问题。一个简单的ArrayList、LinkedList的选择问题，就可能会产生成千上万倍的性能差别。这个时候，数据结构和算法的意义就完全凸显出来了。<br>其实，我觉得，数据结构和算法这个东西，如果你不去学，可能真的这辈子都用不到，也感受不到它的好。但是一旦掌握，你就会常常被它的强大威力所折服。之前你可能需要费很大劲儿来优化的代码，需要花很多心思来设计的架构，用了数据结构和算法之后，很容易就可以解决了。</p><h3 id="⭐-内容小结"><a href="#⭐-内容小结" class="headerlink" title="⭐ 内容小结"></a>⭐ 内容小结</h3><p>我们学习数据结构和算法，并不是为了死记硬背几个知识点。我们的目的是建立时间复杂度、空间复杂度意识，写出高质量的代码，能够设计基础架构，提升编程技能，训练逻辑思维，积攒人生经验，以此获得工作回报，实现你的价值，完善你的人生。</p><p>所以，不管你是业务开发工程师，还是基础架构工程师；不管你是初入职场的初级工程师，还是工作多年的资深架构师，又或者是想转人工智能、区块链这些热门领域的程序员，数据结构与算法作为计算机的基础知识、核心知识，都是必须要掌握的。<br>掌握了数据结构与算法，你看待问题的深度，解决问题的角度就会完全不一样。因为这样的你，就像是站在巨人的肩膀上，拿着生存利器行走世界。数据结构与算法，会为你的编程之路，甚至人生之路打开一扇通往新世界的大门。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法之美 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法之美 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何在一台电脑上管理/切换多个github账户</title>
      <link href="/2020/07/05/git/%E5%A6%82%E4%BD%95%E5%9C%A8%E4%B8%80%E5%8F%B0%E7%94%B5%E8%84%91%E4%B8%8A%E7%AE%A1%E7%90%86-%E5%88%87%E6%8D%A2%E5%A4%9A%E4%B8%AAgithub%E8%B4%A6%E6%88%B7/"/>
      <url>/2020/07/05/git/%E5%A6%82%E4%BD%95%E5%9C%A8%E4%B8%80%E5%8F%B0%E7%94%B5%E8%84%91%E4%B8%8A%E7%AE%A1%E7%90%86-%E5%88%87%E6%8D%A2%E5%A4%9A%E4%B8%AAgithub%E8%B4%A6%E6%88%B7/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>场景：比如个人person和公司work的多个github账号，这个时候在本地做操作，是无法用work账号操作person账号下的git仓库的。</p></blockquote><p>当我用work提交属于person的代码的时候，会出现以下报错，提示无权限.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin master</span><br><span class="line">ERROR: Permission to person&#x2F;git-start.git denied to work.</span><br><span class="line">fatal: Could not read from remote repository.</span><br></pre></td></tr></table></figure><br><a id="more"></a></p><p>使用git remote -v可查看当前仓库的远程git地址。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git remote -v</span><br><span class="line">origin git@github.com:person&#x2F;git-start.git (fetch)</span><br><span class="line">origin git@github.com:person&#x2F;git-start.git (push)</span><br></pre></td></tr></table></figure></p><p>那么，一台电脑上如何管理多个github账户呢?</p><hr><h3 id="设置SSH密钥"><a href="#设置SSH密钥" class="headerlink" title="设置SSH密钥"></a>设置SSH密钥</h3><p>创建多个SSH密钥，并保存在对应的文件中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cd ~&#x2F;.ssh</span><br><span class="line">ssh-keygen -t rsa -C &quot;work@163.com&quot;</span><br><span class="line"></span><br><span class="line">ssh-keygen -t rsa -C &quot;person@163.com&quot;</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure><br>以上创建出id_rsa_work, id_rsa_work.pub和id_rsa_person, id_rsa_person.pub四份文件</p><hr><h3 id="将SSH密钥添加到Github账户"><a href="#将SSH密钥添加到Github账户" class="headerlink" title="将SSH密钥添加到Github账户"></a>将SSH密钥添加到Github账户</h3><p>将密钥复制到剪切板<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pbcopy &lt; ~&#x2F;.ssh&#x2F;id_rsa_work.pub</span><br></pre></td></tr></table></figure><br>将生成的密钥中的公钥内容(即.pub文件)的内容添加到不同的github账户中，流程如下:</p><ul><li>转到github的帐户设置</li><li>点击“SSH密钥”，然后“添加SSH密钥”</li><li>将密钥粘贴到“密钥”字段并添加相关标题</li><li>点击“添加密钥”，然后输入您的Github密码进行确认</li></ul><h3 id="创建config配置文件来单独管理密钥"><a href="#创建config配置文件来单独管理密钥" class="headerlink" title="创建config配置文件来单独管理密钥"></a>创建config配置文件来单独管理密钥</h3><blockquote><p>$ cd ~/.ssh/<br>$ sudo vim config</p></blockquote><p>编辑config文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># work</span><br><span class="line">Host work</span><br><span class="line">   HostName github.com</span><br><span class="line">   User git</span><br><span class="line">   IdentityFile ~&#x2F;.ssh&#x2F;id_rsa_work</span><br><span class="line"></span><br><span class="line"># person</span><br><span class="line">Host person</span><br><span class="line">   HostName github.com</span><br><span class="line">   User git</span><br><span class="line">   IdentityFile ~&#x2F;.ssh&#x2F;id_rsa_person</span><br></pre></td></tr></table></figure></p><p>添加新的密钥<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-add id_rsa_work</span><br><span class="line">$ ssh-add id_rsa_person</span><br></pre></td></tr></table></figure></p><p>查看当前的密钥列表，查看是否添加成功<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-add -l</span><br></pre></td></tr></table></figure></p><p>测试以确保Github识别密钥：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ ssh -T work</span><br><span class="line">Hi work! You&#39;ve successfully authenticated, but GitHub does not provide shell access.</span><br><span class="line"></span><br><span class="line">$ ssh -T person</span><br><span class="line">Hi person! You&#39;ve successfully authenticated, but GitHub does not provide shell access.</span><br></pre></td></tr></table></figure></p><hr><h3 id="试一下"><a href="#试一下" class="headerlink" title="试一下"></a>试一下</h3><p>在和远程库交互的时候，还有一点要注意，即git仓库地址的更改。<br>首先，回到命令行上，创建一个测试目录：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cd ~&#x2F;documents</span><br><span class="line">$ mkdir git-start</span><br><span class="line">$ cd git-start</span><br></pre></td></tr></table></figure></p><p>使用work账号，向Github添加一个空白的“readme.md”文件和PUSH：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ touch readme.md</span><br><span class="line">$ git init</span><br><span class="line">$ git add .</span><br><span class="line">$ git commit -am &quot;first commit&quot;</span><br><span class="line">$ git remote add origin git@work:work&#x2F;git-start.git</span><br><span class="line">$ git push origin master</span><br></pre></td></tr></table></figure></p><p>注意我们如何使用自定义帐户git@work，而不是git@github.com!<br>对于git@work:work/git-start.git。第一个work是在config文件里创建的Host，第二个work为你github的用户名。<br>再试一下person的PUSH和PULL操作，看是否成功</p><p><strong>tips：</strong>更改远程仓库的命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git remote set-url origin git@work:work&#x2F;git-start.git</span><br></pre></td></tr></table></figure></p><p>总结，一台计算机上管理多个github账户的核心就是：</p><ul><li>ssh密钥</li><li>config文件配置</li><li>git仓库远程地址的配置</li></ul><blockquote><p>ps: git常用命令</p><ul><li>git branch branchName(在本地创建一个命名为branchName的分支)</li><li>git branch 查看当前自己所在的分支</li><li>git branch -a 查看服务器的所有分支以及自己当前所在的分支</li><li>git checkout branchName 切换本地分支</li><li>git push origin branchName(把命名为branchName的本地分支推送到服务器)</li><li>git checkout —track origin/branchName (切换为远程服务器上的命名为branchName的远程分支)</li><li>如果你的搭档要把他本地的分支给关联到服务器上命名为branchName的远程分支，请执行以下操作，git branch —set-upstream localBranchName origin/branchName  （为本地分支添加一个对应的远程分支 与之相对应）-&gt;这行命令用来关联本地的分支与服务器上的分支</li><li>git push origin branchName（提交代码到远程服务器上命名为branchName的分支上）</li><li>git pull origin branchName （从远程分支上拉取代码）</li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
            <tag> 多账号配置 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>新一代缓存Caffeine</title>
      <link href="/2020/07/05/%E6%9C%AC%E5%9C%B0%E7%BC%93%E5%AD%98/%E6%96%B0%E4%B8%80%E4%BB%A3%E7%BC%93%E5%AD%98Caffeine/"/>
      <url>/2020/07/05/%E6%9C%AC%E5%9C%B0%E7%BC%93%E5%AD%98/%E6%96%B0%E4%B8%80%E4%BB%A3%E7%BC%93%E5%AD%98Caffeine/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      
      
      <categories>
          
          <category> Caffeine </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 本地缓存 </tag>
            
            <tag> Caffeine </tag>
            
            <tag> 性能 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高性能缓存库Caffeine介绍及实践</title>
      <link href="/2020/07/05/%E6%9C%AC%E5%9C%B0%E7%BC%93%E5%AD%98/%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%93%E5%AD%98%E5%BA%93Caffeine%E4%BB%8B%E7%BB%8D%E5%8F%8A%E5%AE%9E%E8%B7%B5/"/>
      <url>/2020/07/05/%E6%9C%AC%E5%9C%B0%E7%BC%93%E5%AD%98/%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%93%E5%AD%98%E5%BA%93Caffeine%E4%BB%8B%E7%BB%8D%E5%8F%8A%E5%AE%9E%E8%B7%B5/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p>本文我们将介绍Caffeine - 一个Java高性能缓存库。缓存和Map之间的一个根本区别是缓存会将储存的元素逐出。逐出策略决定了在什么时间应该删除哪些对象，逐出策略直接影响缓存的命中率，这是缓存库的关键特征。Caffeine使用<font color = #00FFFF size=5 face="STCAIYUN">Window TinyLfu逐出策略</font>，该策略提供了接近最佳的命中率。</p><a id="more"></a><hr><h2 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h2><p>首先在pom.xml文件中添加Caffeine相关依赖：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.github.ben-manes.caffeine&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;caffeine&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.5.5&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure></p><blockquote><p>ps: 您可以在Maven Central上找到最新版本的Caffeine</p></blockquote><hr><h2 id="缓存填充"><a href="#缓存填充" class="headerlink" title="缓存填充"></a>缓存填充</h2><p>让我们集中讨论Caffeine的三种缓存填充策略：手动，同步加载和异步加载。</p><p>首先，让我们创建一个用于存储到缓存中的DataObject类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DataObject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String data;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> objectCounter = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// standard constructors/getters</span></span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DataObject <span class="title">get</span><span class="params">(String data)</span> </span>&#123;</span><br><span class="line">        objectCounter++;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DataObject(data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="手动填充"><a href="#手动填充" class="headerlink" title="手动填充"></a>手动填充</h3><p>在这种策略中，我们手动将值插入缓存中，并在后面检索它们。<br>让我们初始化缓存：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Cache&lt;String, DataObject&gt; cache = Caffeine.newBuilder()</span><br><span class="line">  .expireAfterWrite(<span class="number">1</span>, TimeUnit.MINUTES)</span><br><span class="line">  .maximumSize(<span class="number">100</span>)</span><br><span class="line">  .build();</span><br></pre></td></tr></table></figure></p><p>现在，我们可以使用getIfPresent方法从缓存中获取值。如果缓存中不存在该值，则此方法将返回null：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String key = <span class="string">"A"</span>;</span><br><span class="line">DataObject dataObject = cache.getIfPresent(key);</span><br><span class="line"> </span><br><span class="line">assertNull(dataObject);</span><br></pre></td></tr></table></figure></p><p>我们可以使用put方法手动将值插入缓存：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cache.put(key, dataObject);</span><br><span class="line">dataObject = cache.getIfPresent(key);</span><br><span class="line"> </span><br><span class="line">assertNotNull(dataObject);</span><br></pre></td></tr></table></figure><br>我们还可以使用get方法获取值，该方法将Lambda函数和键作为参数。如果缓存中不存在此键，则此Lambda函数将用于提供返回值，并且该返回值将在计算后插入缓存中：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dataObject = cache.get(key, k -&gt; DataObject.get(<span class="string">"Data for A"</span>));</span><br><span class="line"> </span><br><span class="line">assertNotNull(dataObject);</span><br><span class="line">assertEquals(<span class="string">"Data for A"</span>, dataObject.getData());</span><br></pre></td></tr></table></figure><br>get方法以原子方式（atomically）执行计算。这意味着计算将只进行一次，即使多个线程同时请求该值。这就是为什么使用get比getIfPresent更好。</p><p>有时我们需要手动使某些缓存的值无效：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cache.invalidate(key);</span><br><span class="line">dataObject = cache.getIfPresent(key);</span><br><span class="line"> </span><br><span class="line">assertNull(dataObject);</span><br></pre></td></tr></table></figure></p><h3 id="同步加载"><a href="#同步加载" class="headerlink" title="同步加载"></a>同步加载</h3><p>这种加载缓存的方法具有一个函数，该函数用于初始化值，类似于手动策略的get方法。让我们看看如何使用它。首先，我们需要初始化缓存：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LoadingCache&lt;String, DataObject&gt; cache = Caffeine.newBuilder()</span><br><span class="line">  .maximumSize(<span class="number">100</span>)</span><br><span class="line">  .expireAfterWrite(<span class="number">1</span>, TimeUnit.MINUTES)</span><br><span class="line">  .build(k -&gt; DataObject.get(<span class="string">"Data for "</span> + k));</span><br></pre></td></tr></table></figure></p><p>现在，我们可以使用get方法检索值：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DataObject dataObject = cache.get(key);</span><br><span class="line"> </span><br><span class="line">assertNotNull(dataObject);</span><br><span class="line">assertEquals(<span class="string">"Data for "</span> + key, dataObject.getData());</span><br></pre></td></tr></table></figure></p><p>我们还可以使用getAll方法获得一组值：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, DataObject&gt; dataObjectMap = cache.getAll(Arrays.asList(<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>));</span><br><span class="line"> </span><br><span class="line">assertEquals(<span class="number">3</span>, dataObjectMap.size());</span><br></pre></td></tr></table></figure><br>从传递给build方法的初始化函数中检索值。这样就可以通过缓存在来装饰访问值。</p><h3 id="异步加载"><a href="#异步加载" class="headerlink" title="异步加载"></a>异步加载</h3><p>该策略与先前的策略相同，但是异步执行操作，并返回保存实际值的CompletableFuture：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">AsyncLoadingCache&lt;String, DataObject&gt; cache = Caffeine.newBuilder()</span><br><span class="line">  .maximumSize(<span class="number">100</span>)</span><br><span class="line">  .expireAfterWrite(<span class="number">1</span>, TimeUnit.MINUTES)</span><br><span class="line">  .buildAsync(k -&gt; DataObject.get(<span class="string">"Data for "</span> + k));</span><br></pre></td></tr></table></figure></p><p>考虑到它们返回CompletableFuture的事实，我们可以以相同的方式使用get和getAll方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">String key = <span class="string">"A"</span>;</span><br><span class="line"> </span><br><span class="line">cache.get(key).thenAccept(dataObject -&gt; &#123;</span><br><span class="line">    assertNotNull(dataObject);</span><br><span class="line">    assertEquals(<span class="string">"Data for "</span> + key, dataObject.getData());</span><br><span class="line">&#125;);</span><br><span class="line"> </span><br><span class="line">cache.getAll(Arrays.asList(<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>))</span><br><span class="line">  .thenAccept(dataObjectMap -&gt; assertEquals(<span class="number">3</span>, dataObjectMap.size()));</span><br></pre></td></tr></table></figure></p><p>CompletableFuture具有丰富而有用的API，您可以在<a href="https://www.baeldung.com/java-completablefuture" target="_blank" rel="noopener">本文</a>中了解更多信息。</p><hr><h2 id="逐出元素"><a href="#逐出元素" class="headerlink" title="逐出元素"></a>逐出元素</h2><p>Caffeine具有三种元素逐出策略：<code>基于容量</code>，<code>基于时间</code>和<code>基于引用</code>。</p><h3 id="基于容量的逐出"><a href="#基于容量的逐出" class="headerlink" title="基于容量的逐出"></a>基于容量的逐出</h3><p>这种逐出发生在超过配置的缓存容量大小限制时。有两种获取容量当前占用量的方法，计算缓存中的对象数量或获取它们的权重。<br>让我们看看如何处理缓存中的对象。初始化高速缓存时，其大小等于零：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">LoadingCache&lt;String, DataObject&gt; cache = Caffeine.newBuilder()</span><br><span class="line">  .maximumSize(<span class="number">1</span>)</span><br><span class="line">  .build(k -&gt; DataObject.get(<span class="string">"Data for "</span> + k));</span><br><span class="line"> </span><br><span class="line">assertEquals(<span class="number">0</span>, cache.estimatedSize());</span><br></pre></td></tr></table></figure></p><p>当我们添加一个值时，大小显然会增加：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cache.get(<span class="string">"A"</span>);</span><br><span class="line"> </span><br><span class="line">assertEquals(<span class="number">1</span>, cache.estimatedSize());</span><br></pre></td></tr></table></figure><br>我们可以将第二个值添加到缓存中，从而导致删除第一个值：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cache.get(<span class="string">"B"</span>);</span><br><span class="line">cache.cleanUp();</span><br><span class="line"> </span><br><span class="line">assertEquals(<span class="number">1</span>, cache.estimatedSize());</span><br></pre></td></tr></table></figure><br>值得一提的是，在获取缓存大小之前，我们先调用cleanUp方法。这是因为缓存逐出是异步执行的，并且此方法有助于等待逐出操作的完成。<br>我们还可以传递一个<strong><em>weigher</em></strong>函数来指定缓存值的权重大小：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">LoadingCache&lt;String, DataObject&gt; cache = Caffeine.newBuilder()</span><br><span class="line">  .maximumWeight(<span class="number">10</span>)</span><br><span class="line">  .weigher((k,v) -&gt; <span class="number">5</span>)</span><br><span class="line">  .build(k -&gt; DataObject.get(<span class="string">"Data for "</span> + k));</span><br><span class="line"> </span><br><span class="line">assertEquals(<span class="number">0</span>, cache.estimatedSize());</span><br><span class="line"> </span><br><span class="line">cache.get(<span class="string">"A"</span>);</span><br><span class="line">assertEquals(<span class="number">1</span>, cache.estimatedSize());</span><br><span class="line"> </span><br><span class="line">cache.get(<span class="string">"B"</span>);</span><br><span class="line">assertEquals(<span class="number">2</span>, cache.estimatedSize());</span><br></pre></td></tr></table></figure></p><p>当权重超过10时，将按照时间顺序从缓存中删除多余的值：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cache.get(<span class="string">"C"</span>);</span><br><span class="line">cache.cleanUp();</span><br><span class="line"> </span><br><span class="line">assertEquals(<span class="number">2</span>, cache.estimatedSize());</span><br></pre></td></tr></table></figure></p><h3 id="基于时间的逐出"><a href="#基于时间的逐出" class="headerlink" title="基于时间的逐出"></a>基于时间的逐出</h3><p>此逐出策略基于元素的到期时间，并具有三种类型：</p><ul><li><strong>Expire after access</strong> — 自上次读取或写入发生以来，经过过期时间之后该元素到期。</li><li><strong>Expire after write</strong> — 自上次写入以来，在经过过期时间之后该元素过期。</li><li><strong>Custom policy</strong> — 通过Expiry实现分别计算每个元素的到期时间。</li></ul><p>让我们使用expireAfterAccess方法配置访问后过期策略：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LoadingCache&lt;String, DataObject&gt; cache = Caffeine.newBuilder()</span><br><span class="line">  .expireAfterAccess(<span class="number">5</span>, TimeUnit.MINUTES)</span><br><span class="line">  .build(k -&gt; DataObject.get(<span class="string">"Data for "</span> + k));</span><br></pre></td></tr></table></figure></p><p>要配置写后过期策略，我们使用expireAfterWrite方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cache = Caffeine.newBuilder()</span><br><span class="line">  .expireAfterWrite(<span class="number">10</span>, TimeUnit.SECONDS)</span><br><span class="line">  .weakKeys()</span><br><span class="line">  .weakValues()</span><br><span class="line">  .build(k -&gt; DataObject.get(<span class="string">"Data for "</span> + k));</span><br></pre></td></tr></table></figure><br>要初始化自定义策略，我们需要实现Expiry接口：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">cache = Caffeine.newBuilder().expireAfter(<span class="keyword">new</span> Expiry&lt;String, DataObject&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">expireAfterCreate</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      String key, DataObject value, <span class="keyword">long</span> currentTime)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value.getData().length() * <span class="number">1000</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">expireAfterUpdate</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      String key, DataObject value, <span class="keyword">long</span> currentTime, <span class="keyword">long</span> currentDuration)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> currentDuration;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">expireAfterRead</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      String key, DataObject value, <span class="keyword">long</span> currentTime, <span class="keyword">long</span> currentDuration)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> currentDuration;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).build(k -&gt; DataObject.get(<span class="string">"Data for "</span> + k));</span><br></pre></td></tr></table></figure></p><h3 id="基于引用的逐出"><a href="#基于引用的逐出" class="headerlink" title="基于引用的逐出"></a>基于引用的逐出</h3><p>我们可以将缓存配置为允许垃圾回收缓存的键或值。为此，我们将为键和值配置WeakRefence的用法，并且我们只能为值的垃圾收集配置为SoftReference。</p><p>当对象没有任何强引用时，WeakRefence用法允许对对象进行垃圾回收。 SoftReference允许根据JVM的全局“最近最少使用”策略对对象进行垃圾收集。有关Java引用的更多详细信息，请参见<a href="https://www.baeldung.com/java-weakhashmap" target="_blank" rel="noopener">此处</a>。</p><p>我们应该使用Caffeine.weakKeys()，Caffeine.weakValues()和Caffeine.softValues()来启用每个选项：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">LoadingCache&lt;String, DataObject&gt; cache = Caffeine.newBuilder()</span><br><span class="line">  .expireAfterWrite(<span class="number">10</span>, TimeUnit.SECONDS)</span><br><span class="line">  .weakKeys()</span><br><span class="line">  .weakValues()</span><br><span class="line">  .build(k -&gt; DataObject.get(<span class="string">"Data for "</span> + k));</span><br><span class="line"> </span><br><span class="line">cache = Caffeine.newBuilder()</span><br><span class="line">  .expireAfterWrite(<span class="number">10</span>, TimeUnit.SECONDS)</span><br><span class="line">  .softValues()</span><br><span class="line">  .build(k -&gt; DataObject.get(<span class="string">"Data for "</span> + k));</span><br></pre></td></tr></table></figure></p><hr><h2 id="刷新缓存"><a href="#刷新缓存" class="headerlink" title="刷新缓存"></a>刷新缓存</h2><p>可以将缓存配置为在定义的时间段后自动刷新元素。让我们看看如何使用refreshAfterWrite方法执行此操作：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Caffeine.newBuilder()</span><br><span class="line">  .refreshAfterWrite(<span class="number">1</span>, TimeUnit.MINUTES)</span><br><span class="line">  .build(k -&gt; DataObject.get(<span class="string">"Data for "</span> + k));</span><br></pre></td></tr></table></figure></p><p>在这里，我们应该了解expireAfter和refreshAfter之间的区别。前者当请求过期元素时，执行将阻塞，直到build()计算出新值为止。<br>但是后者将返回旧值并异步计算出新值并插入缓存中，此时被刷新的元素的过期时间将重新开始计时计算。</p><hr><h2 id="统计"><a href="#统计" class="headerlink" title="统计"></a>统计</h2><p>Caffeine可以记录有关缓存使用情况的统计信息：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">LoadingCache&lt;String, DataObject&gt; cache = Caffeine.newBuilder()</span><br><span class="line">  .maximumSize(<span class="number">100</span>)</span><br><span class="line">  .recordStats()</span><br><span class="line">  .build(k -&gt; DataObject.get(<span class="string">"Data for "</span> + k));</span><br><span class="line">cache.get(<span class="string">"A"</span>);</span><br><span class="line">cache.get(<span class="string">"A"</span>);</span><br><span class="line"> </span><br><span class="line">assertEquals(<span class="number">1</span>, cache.stats().hitCount());</span><br><span class="line">assertEquals(<span class="number">1</span>, cache.stats().missCount());</span><br></pre></td></tr></table></figure><br>我们将recordStats传递给它，recordStats创建StatsCounter的实现。每次与统计相关的更改都将推送给此对象。</p><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在本文中，我们熟悉了Java的Caffeine缓存库。我们了解了如何配置和填充缓存，以及如何根据需要选择适当的过期或刷新策略。</p>]]></content>
      
      
      <categories>
          
          <category> Caffeine </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 本地缓存 </tag>
            
            <tag> Caffeine </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
